之前项目中会遇到需要计算求和，知道和丢失精度有关，但原因不是很清楚，看到这个[参考](https://zhuanlan.zhihu.com/p/100353781)，学习下。

JS 在加减乘除运算中，结果可能会和手算的不一样，即丢失精度，如：

```js
// 加法 =====================
0.1 + 0.2 = 0.30000000000000004
0.7 + 0.1 = 0.7999999999999999
0.2 + 0.4 = 0.6000000000000001

// 减法 =====================
1.5 - 1.2 = 0.30000000000000004
0.3 - 0.2 = 0.09999999999999998

// 乘法 =====================
19.9 * 100 = 1989.9999999999998
0.8 * 3 = 2.4000000000000004
35.41 * 100 = 3540.9999999999995

// 除法 =====================
0.3 / 0.1 = 2.9999999999999996
0.69 / 10 = 0.06899999999999999
```

原因：js 是以 64 位双精度浮点数来存储 Number 类型，即对于每个数、js 最多存储其二进制数的 64 位。通俗来讲，像 1/3 这种无限循环小数，js 只能存储 64 位的话，存的是近似值，取出来再用时就会出现精度问题。

一些概念：

- **浮点数**：带有小数的数据。包括单精度浮点数(float),双精度浮点数（ddouble）
- **单精度浮点数（float）**：单精度浮点数在内存中占 4 个字节、有效数字 8 位
- **双精度浮点数（double）**：双精度浮点数在内存中占 8 个字节、有效数字 16 位

位数含义：
| | 符号位 | 指数位 |小数位 |指数偏移量 |
| :-----| :----- | :----- | :----- | :----- |
| float | 1 位[31] | 8 位[30-23] |23 位[22-0] |127 |
| double | 1 位[63] | 11 位[62-52] |52 位[51-0] |1023 |

js 以二进制存储数据例子：27.5

1. 转化为二进制数：27.5->11011.1
2. 转化为科学计数法：11011.1->1.10111\*(2 的 4 次方)
3. 转化为 64 位浮点数：

- 符号位：1。正数为 1，负数为 0
- 指数位：10000000011。指数偏移量+4=1023+4=1027，1027 转化为二进制 10000000011
- 小数位： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000。10111 向后补够 52 位
- 组合：0100 0000 0011 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000。符号位+指数位+小数位

这时候再来看丢失精度中的例子，如 0.2+0.1：

1. 0.2 转化为 64 位双精度浮点数：

- 0.2 转化为二进制：0.001100（1100 循环）
- 转化为科学计数法：0.001100（1100 循环）->1.1001100(1100 循环)\*(2 的-3 次方)
- 转化为 64 位浮点数：1+01111111100（1020 的二进制数）+1001100...11010
- 组合：10111111111001100...110

2. 0.1 转化为 64 位双精度浮点数：

- 0.1 转化为二进制：0.0001100（1100 循环）
- 转化为科学计数法：0.0001100（1100 循环）->1.1001100(1100 循环)\*(2 的-4 次方)
- 转化为 64 位浮点数：1+01111111011（1019 的二进制数）+1001100...11010
- 组合：1011111110111001100...1101

3. 取出相加
   0.2-> 0 01111111100 1001100110011001100110011001100110011001100110011010->
   0.0011001100110011001100110011001100110011001100110011010
   0.1-> 0 01111111011 1001100110011001100110011001100110011001100110011010->
   0.00011001100110011001100110011001100110011001100110011010
   和：0.01001100110011001100110011001100110011001100110011001110->0.30000000000000004

toPrecision() 方法以指定的精度返回该数值对象的字符串表示

0.1.toPrecision(21)='0.100000000000000005551'

ES6新增常量：Number.EPSILON，浮点数计算的误差范围，小于这个数基本上可靠

### 小数最后一位为 5 时 toFixed()不精确

firefox/chrome 中 toFixed 兼容性问题

```js
;(1.33335).toFixed(4) //1.3334 正确
;(1.333335).toFixed(5) //1.33333 不正确
;(1.005).toFixed(2) //1.00 不正确
```

修复方法 1:

```js
/*
 * 修复firefox/chrome中toFixed兼容性问题
 * firefox/chrome中，对于小数最后一位为5时进位不正确，
 * 修复方式即判断最后一位为5的，改成6，再调用toFixed
   number {原始数字}
   precision {位数}
 */
function toFixed(number, precision) {
  var str = number + ''
  var len = str.length
  var last = str.substring(len - 1, len)
  if (last == '5') {
    last = '6'
    str = str.substring(0, len - 1) + last
    return (str - 0).toFixed(precision)
  } else {
    return number.toFixed(precision)
  }
}
console.log(toFixed(1.333335, 5))//1.33334
```

修复方法2:
```js
//先扩大再缩小法 
function toFixed(num, s) {
    var times = Math.pow(10, s)
    // 0.5 为了舍入
    var des = num * times + 0.5
    // 去除小数
    des = parseInt(des, 10) / times
    return des + ''
}
console.log(toFixed(1.333332, 5)) //1.33333
```


### 数据展示
当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示
```js
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // true
```
精度为什么选择12？ 可以解决掉大部分精度问题

### 浮点数计算
