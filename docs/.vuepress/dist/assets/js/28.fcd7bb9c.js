(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{250:function(e,t,a){"use strict";a.r(t);var r=a(0),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://www.cxymsg.com/guide/vue.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"vue常用的修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue常用的修饰符","aria-hidden":"true"}},[e._v("#")]),e._v(" vue常用的修饰符?")]),e._v(" "),a("p",[e._v(".stop .prevent .once .trim")]),e._v(" "),a("h2",{attrs:{id:"vue-cli-工程常用的-npm-命令有哪些？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-cli-工程常用的-npm-命令有哪些？","aria-hidden":"true"}},[e._v("#")]),e._v(" vue-cli 工程常用的 npm 命令有哪些？")]),e._v(" "),a("ol",[a("li",[e._v("npm install：下载 node_modules 资源包的命令")]),e._v(" "),a("li",[e._v("npm run dev： 启动 vue-cli 开发环境的 npm命令")]),e._v(" "),a("li",[e._v("npm run build： vue-cli 生成 生产环境部署资源 的 npm命令")]),e._v(" "),a("li",[e._v("npm run build--report： 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令")])]),e._v(" "),a("h2",{attrs:{id:"vue中-keep-alive-组件的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中-keep-alive-组件的作用","aria-hidden":"true"}},[e._v("#")]),e._v(" vue中 keep-alive 组件的作用?")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#keep-alive",target:"_blank",rel:"noopener noreferrer"}},[e._v("文档"),a("OutboundLink")],1),e._v("\n主要用于保留组件状态或避免重新渲染。")]),e._v(" "),a("p",[e._v("当组件在"),a("code",[e._v("<keep-alive>")]),e._v(" 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。\n动态切换组件时会重新加载，可以将组件缓存到内存中，使用keep-alive")]),e._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("keep-alive")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("：max")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("10"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n\t"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("router-view")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v(":seller")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("seller"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("router-view")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("keep-alive")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("router-view")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("\x3c!-- 是vrouter-view ue-router中渲染路径匹配到的组件 --\x3e")]),e._v("\n")])])]),a("ul",[a("li",[e._v("只能有一个组件被渲染，如包含v-for就不行")]),e._v(" "),a("li",[e._v(":max可以限制最多缓存多少个组件")])]),e._v(" "),a("h2",{attrs:{id:"computed和watch有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch有什么区别","aria-hidden":"true"}},[e._v("#")]),e._v(" computed和watch有什么区别?")]),e._v(" "),a("p",[e._v("缓存性、调用方法")]),e._v(" "),a("h2",{attrs:{id:"构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？","aria-hidden":"true"}},[e._v("#")]),e._v(" 构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？")]),e._v(" "),a("ol",[a("li",[e._v("vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。")]),e._v(" "),a("li",[e._v("vue-router：vue官方推荐使用的路由框架。")]),e._v(" "),a("li",[e._v("vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。")]),e._v(" "),a("li",[e._v("axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。")]),e._v(" "),a("li",[e._v("vux等：一个专为vue设计的移动端UI组件库。")]),e._v(" "),a("li",[e._v("创建一个emit.js文件，用于vue事件机制的管理。")]),e._v(" "),a("li",[e._v("webpack：模块加载和vue-cli工程打包器。")])]),e._v(" "),a("h2",{attrs:{id:"vue中key的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue中key的作用","aria-hidden":"true"}},[e._v("#")]),e._v(" vue中key的作用?")]),e._v(" "),a("ol",[a("li",[e._v("更高效的更新虚拟DOM;")]),e._v(" "),a("li",[e._v("保持准确性：如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug")])]),e._v(" "),a("h2",{attrs:{id:"vue为什么没有类似于react中shouldcomponentupdate的生命周期？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue为什么没有类似于react中shouldcomponentupdate的生命周期？","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue为什么没有类似于React中shouldComponentUpdate的生命周期？")]),e._v(" "),a("blockquote",[a("p",[e._v("shouldComponentUpdate():当state或者props变化时，在渲染之前调用，来判断当前组件是否受变化影响，并且是否要渲染，默认返回false")])]),e._v(" "),a("p",[e._v("变化侦测方式不同:")]),e._v(" "),a("p",[e._v("React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能.")]),e._v(" "),a("p",[e._v("Vue是pull+push的方式侦测变化的,"),a("strong",[e._v("在一开始就知道那个组件发生了变化")]),e._v(",因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期.")]),e._v(" "),a("h2",{attrs:{id:"既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#既然vue通过数据劫持可以精准探测数据变化-为什么还需要虚拟dom进行diff检测差异","aria-hidden":"true"}},[e._v("#")]),e._v(" 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?")]),e._v(" "),a("p",[e._v("现代前端框架有两种方式侦测变化,一种是pull一种是push")]),e._v(" "),a("ul",[a("li",[e._v("pull")])]),e._v(" "),a("p",[e._v("其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。")]),e._v(" "),a("ul",[a("li",[e._v("push")])]),e._v(" "),a("p",[e._v("Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的.")]),e._v(" "),a("h2",{attrs:{id:"对生命周期的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对生命周期的理解","aria-hidden":"true"}},[e._v("#")]),e._v(" 对生命周期的理解")]),e._v(" "),a("ul",[a("li",[e._v("生命周期是什么")])]),e._v(" "),a("p",[e._v("Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是Vue的生命周期。")]),e._v(" "),a("ul",[a("li",[e._v("各个生命周期的作用")])]),e._v(" "),a("p",[a("strong",[e._v("beforeCreate")]),e._v("\t组件实例被创建之初，组件的属性生效之前")]),e._v(" "),a("p",[a("strong",[e._v("created")]),e._v("\t组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用")]),e._v(" "),a("p",[a("strong",[e._v("beforeMount")]),e._v("\t在挂载开始之前被调用：相关的 render 函数首次被调用")]),e._v(" "),a("p",[a("strong",[e._v("mounted")]),e._v("\tel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子")]),e._v(" "),a("p",[a("strong",[e._v("beforeUpdate")]),e._v("\t组件数据更新之前调用，发生在虚拟 DOM 打补丁之前")]),e._v(" "),a("p",[a("strong",[e._v("update")]),e._v("\t组件数据更新之后")]),e._v(" "),a("p",[a("strong",[e._v("activited")]),e._v("\tkeep-alive专属，组件被激活时调用")]),e._v(" "),a("p",[a("strong",[e._v("deadctivated")]),e._v("\tkeep-alive专属，组件被销毁时调用")]),e._v(" "),a("p",[a("strong",[e._v("beforeDestory")]),e._v("\t组件销毁前调用")]),e._v(" "),a("p",[a("strong",[e._v("destoryed")]),e._v("\t组件销毁后调用")]),e._v(" "),a("ul",[a("li",[e._v("生命周期示意图\n"),a("img",{attrs:{src:"/articles/interview/1.png",width:"800px/"}})])]),e._v(" "),a("h2",{attrs:{id:"vue组件如何通信？vue中8种组件通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue组件如何通信？vue中8种组件通信方式","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue组件如何通信？vue中8种组件通信方式")]),e._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://juejin.im/post/5d267dcdf265da1b957081a3#heading-15",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),a("OutboundLink")],1)])]),e._v(" "),a("ul",[a("li",[e._v("props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。")]),e._v(" "),a("li",[e._v("EventBus: 通过EventBus进行信息的发布与订阅")]),e._v(" "),a("li",[e._v("vuex: 是全局数据管理库，可以通过vuex管理全局的数据流")]),e._v(" "),a("li",[e._v("$attrs/$listeners: Vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信")]),e._v(" "),a("li",[e._v("provide/inject：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础")]),e._v(" "),a("li",[e._v("$children/$parent")]),e._v(" "),a("li",[e._v("localstorage")])]),e._v(" "),a("h2",{attrs:{id:"vue是如何实现双向绑定的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue是如何实现双向绑定的","aria-hidden":"true"}},[e._v("#")]),e._v(" ?Vue是如何实现双向绑定的?")]),e._v(" "),a("p",[e._v("利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,然后根据变化进行后续响应,在vue3.0中通过Proxy代理对象进行类似的操作。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf",target:"_blank",rel:"noopener noreferrer"}},[e._v("详解"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"proxy与object-defineproperty的优劣对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy与object-defineproperty的优劣对比","aria-hidden":"true"}},[e._v("#")]),e._v(" ?Proxy与Object.defineProperty的优劣对比?")]),e._v(" "),a("p",[e._v("Proxy的优势如下:")]),e._v(" "),a("ul",[a("li",[e._v("Proxy可以直接监听对象而非属性")]),e._v(" "),a("li",[e._v("Proxy可以直接监听数组的变化")]),e._v(" "),a("li",[e._v("Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的")]),e._v(" "),a("li",[e._v("Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改")]),e._v(" "),a("li",[e._v("Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利")])]),e._v(" "),a("p",[e._v("Object.defineProperty的优势如下:")]),e._v(" "),a("ul",[a("li",[e._v("兼容性好,支持IE9")])]),e._v(" "),a("h2",{attrs:{id:"你是如何理解vue的响应式系统的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你是如何理解vue的响应式系统的","aria-hidden":"true"}},[e._v("#")]),e._v(" ?你是如何理解Vue的响应式系统的?")]),e._v(" "),a("ul",[a("li",[e._v("任何一个 Vue Component 都有一个与之对应的 Watcher 实例。")]),e._v(" "),a("li",[e._v("Vue 的 data 上的属性会被添加 getter 和 setter 属性。")]),e._v(" "),a("li",[e._v("当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)")]),e._v(" "),a("li",[e._v("data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.cxymsg.com/guide/reactivity.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("详解"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);